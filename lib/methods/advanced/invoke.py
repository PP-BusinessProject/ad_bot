"""The module with the :meth:`AdBotClient.send`."""

from typing import TYPE_CHECKING

from pyrogram.raw.core import TLObject
from pyrogram.raw.functions.invoke_with_takeout import InvokeWithTakeout
from pyrogram.raw.functions.invoke_without_updates import InvokeWithoutUpdates

from ...ad_bot_session import AdBotSession

if TYPE_CHECKING:
    from ...ad_bot_client import AdBotClient


class Invoke(object):
    async def invoke(
        self: 'AdBotClient',
        /,
        data: TLObject,
        retries: int = AdBotSession.MAX_RETRIES,
        timeout: float = AdBotSession.WAIT_TIMEOUT,
        sleep_threshold: float = None,
        *,
        no_updates: bool = False,
        fetch_peers: bool = True,
    ) -> TLObject:
        """
        Send raw Telegram queries.

        This method makes it possible to manually call every single
        Telegram API method in a low-level manner. Available functions are
        listed in the :obj:`functions <pyrogram.api.functions>` package and may
        accept compound data types from :obj:`types <pyrogram.api.types>` as
        well as bare types such as ``int``, ``str``, etc...

        .. note::

            This is a utility method intended to be used **only** when working
            with raw:obj:`functions <pyrogram.api.functions>` (i.e: a Telegram
            API method you wish to use which is not available yet in the Client
            class as an easy-to-use method).

        Args:
            data (``RawFunction``):
                The API Schema function filled with proper arguments.

            retries (``int``):
                Number of retries.

            timeout (``float``):
                Timeout in seconds.

            sleep_threshold (``float``):
                Sleep threshold in seconds.

        Returns:
            ``RawType``: The raw type response generated by the query.

        Raises:
            RPCError: In case of a Telegram RPC error.
        """
        if not self.is_connected:
            raise ConnectionError('Client has not been started yet.')
        if no_updates or self.no_updates:
            data = InvokeWithoutUpdates(query=data)
        if self.takeout_id:
            data = InvokeWithTakeout(takeout_id=self.takeout_id, query=data)

        resp = await self.session.invoke(
            *(data, retries, timeout),
            sleep_threshold
            if sleep_threshold is not None
            else self.sleep_threshold,
        )
        if fetch_peers:
            peers = getattr(resp, 'users', []) + getattr(resp, 'chats', [])
            if peers:
                await self.fetch_peers(peers)
        return resp
